(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{186:function(v,_,e){v.exports=e.p+"assets/img/16c1a5d709d285e7.882db7b2.jpeg"},266:function(v,_,e){"use strict";e.r(_);var s=e(3),t=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h3",{attrs:{id:"非祖塞异步io"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非祖塞异步io"}},[v._v("#")]),v._v(" 非祖塞异步io")]),v._v(" "),s("p",[v._v("由于 "),s("code",[v._v("Node.js")]),v._v("中采用了非阻塞型"),s("code",[v._v("I/O")]),v._v("机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率。")]),v._v(" "),s("p",[v._v("当某个"),s("code",[v._v("I/O")]),v._v("执行完毕时，将以事件的形式通知执行"),s("code",[v._v("I/O")]),v._v("操作的线程，线程执行这个事件的回调函数。为了处理异步"),s("code",[v._v("I/O")]),v._v("，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。")]),v._v(" "),s("h3",{attrs:{id:"单线程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程"}},[v._v("#")]),v._v(" 单线程")]),v._v(" "),s("p",[s("code",[v._v("Node.js")]),v._v(" 不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞"),s("code",[v._v("I/O")]),v._v("、事件驱动机制，让 "),s("code",[v._v("Node.js")]),v._v(" 程序宏观上也是并行的。使用"),s("code",[v._v("Node.js")]),v._v(" ，一个 8GB 内存的服务器，可以同时处理超过 4 万用户的连接。")]),v._v(" "),s("h3",{attrs:{id:"事件驱动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#事件驱动"}},[v._v("#")]),v._v(" 事件驱动")]),v._v(" "),s("p",[s("code",[v._v("Node.js")]),v._v("中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，又有其他事件产生，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。")]),v._v(" "),s("p",[s("code",[v._v("Node.js")]),v._v(" 底层是 "),s("code",[v._v("C++（V8也是 C++写的）")]),v._v("。底层代码中，近半数都用于事件队列、回调函数队列的构建。用事件驱动来完成服务器的任务调度")]),v._v(" "),s("img",{attrs:{src:e(186)}}),v._v(" "),s("p",[v._v("Node.js 官网的解释图")]),v._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[v._v("   ┌───────────────────────────┐\n┌─>│           timers          │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │     pending callbacks     │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n│  │       idle, prepare       │\n│  └─────────────┬─────────────┘      ┌───────────────┐\n│  ┌─────────────┴─────────────┐      │   incoming:   │\n│  │           poll            │<─────┤  connections, │\n│  └─────────────┬─────────────┘      │   data, etc.  │\n│  ┌─────────────┴─────────────┐      └───────────────┘\n│  │           check           │\n│  └─────────────┬─────────────┘\n│  ┌─────────────┴─────────────┐\n└──┤      close callbacks      │\n   └───────────────────────────┘\n\n")])])]),s("h3",{attrs:{id:"跨平台"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#跨平台"}},[v._v("#")]),v._v(" 跨平台")]),v._v(" "),s("p",[v._v("起初，"),s("code",[v._v("Node")]),v._v(" 只能在"),s("code",[v._v("Linux")]),v._v(" 平台上运行。后来随着 "),s("code",[v._v("Node")]),v._v("的发展，微软注意到了它的存在，并投入了一个团队帮助 "),s("code",[v._v("Node")]),v._v(" 实现 "),s("code",[v._v("Windows")]),v._v(" 平台的兼容，在"),s("code",[v._v("v0.6.0")]),v._v("版本发布时，"),s("code",[v._v("Node")]),v._v(" 已经能够直接在"),s("code",[v._v("Window")]),v._v("平台运行了")]),v._v(" "),s("h3",{attrs:{id:"单线程带来的弊端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#单线程带来的弊端"}},[v._v("#")]),v._v(" 单线程带来的弊端")]),v._v(" "),s("ul",[s("li",[v._v("1.无法利用多核 CPU")]),v._v(" "),s("li",[v._v("2.错误会引起整个应用退出无法继续调用异步I/O")]),v._v(" "),s("li",[v._v("3.大量计算占用 CPU 导致无法继续调用异步I/O")])]),v._v(" "),s("p",[v._v("弊端 1:解决方案")]),v._v(" "),s("ul",[s("li",[v._v("（1）一些管理工具比如pm2，forever 等都可以实现创建多进程解决多核 CUP 的利用率问题。")]),v._v(" "),s("li",[v._v("（2）在 v0.8 版本之前，实现多进程可以使用child_process")]),v._v(" "),s("li",[v._v("（3）在 v0.8 版本之后，可以使用cluster模块，通过主从模式，创建多个工作进程解决多核 CPU 的利用率问题。")])]),v._v(" "),s("p",[v._v("弊端 2:解决方案")]),v._v(" "),s("ul",[s("li",[v._v("（1）Nnigx 反向代理，负载均衡，开多个进程，绑定多个端口；")]),v._v(" "),s("li",[v._v("（2） 一些管理工具比如pm2，forever 等都可以实现进程监控，错误自动重启等")]),v._v(" "),s("li",[v._v("（3）开多个进程监听同一个端口，使用 Node 提供的cluster模块；")]),v._v(" "),s("li",[v._v("（4）未出现cluster之前，也可以使用child_process,创建多子线程监听一个端口。")]),v._v(" "),s("li",[v._v("（5）这里说明下，有上面的这些解决方案，但是写 node 后端代码的时候，异常抛出try catch显得格外有必要。")])]),v._v(" "),s("p",[v._v("弊端 3:解决方案")]),v._v(" "),s("ul",[s("li",[v._v("（1）可以把大量的密集计算像上面一样拆分成多个子线程计算.")]),v._v(" "),s("li",[v._v("（2）但是如果不允许拆分，想计算 100 万的大数据，在一个单线程中，Node 确实显得无能为力，这本身就是 V8 内存限制的弊端。")])]),v._v(" "),s("h3",{attrs:{id:"node-js-的应用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#node-js-的应用场景"}},[v._v("#")]),v._v(" Node.js 的应用场景")]),v._v(" "),s("p",[v._v("善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的 CPU 计算，实际上也相当于这个计算阻塞了这个单线程，就不太适合 Node 开发，但是也不是没有解决方案，只是说不太适合。")]),v._v(" "),s("p",[v._v("当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。")]),v._v(" "),s("p",[v._v("具体场景可以表现为如下：")]),v._v(" "),s("ul",[s("li",[s("p",[v._v("第一大类：用户表单收集系统、后台管理系统、实时交互系统、考试系统、联网软件、高并发量的 web 应用程序；")])]),v._v(" "),s("li",[s("p",[v._v("第二大类：基于 web、canvas 等多人联网游戏；")])]),v._v(" "),s("li",[s("p",[v._v("第三大类：基于 web 的多人实时聊天客户端、聊天室、图文直播；")])]),v._v(" "),s("li",[s("p",[v._v("第四大类：单页面浏览器应用程序；")])]),v._v(" "),s("li",[s("p",[v._v("第五大类：操作数据库、为前端和移动端提供基于json的 API；")])])]),v._v(" "),s("h3",{attrs:{id:"一些文档"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一些文档"}},[v._v("#")]),v._v(" 一些文档")]),v._v(" "),s("p",[s("a",{attrs:{href:""}},[v._v("node的api http://nodejs.cn/api/")])])])}),[],!1,null,null,null);_.default=t.exports}}]);