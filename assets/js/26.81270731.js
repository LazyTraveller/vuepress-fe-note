(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{213:function(v,_,t){"use strict";t.r(_);var e=t(3),s=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"javascript-是单线程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#javascript-是单线程"}},[v._v("#")]),v._v(" JavaScript 是单线程")]),v._v(" "),t("blockquote",[t("p",[v._v("本文来源："),t("a",{attrs:{href:"https://juejin.im/post/5bc2a2d9f265da0ab915edd8",target:"_blank",rel:"noopener noreferrer"}},[v._v("全方位了解 JavaScript 的 Event Loop"),t("OutboundLink")],1)])]),v._v(" "),t("p",[v._v("首先我们了解一下进程和线程的概念和关系：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("进程")]),v._v("：运行的程序就是一个进程，比如你正在运行的浏览器，它会有一个进程；")]),v._v(" "),t("li",[t("strong",[v._v("线程")]),v._v("：程序中独立运行的代码段。"),t("strong",[v._v("一个进程")]),v._v(" 由单个或多个 "),t("strong",[v._v("线程")]),v._v(" 组成，线程是负责执行代码的。")])]),v._v(" "),t("p",[v._v("单线程与多线程的区别：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("单线程")]),v._v("：从头执行到尾，一行行执行，如果其中一行代码报错，那么剩下的代码将不再执行。同时容易代码阻塞。")]),v._v(" "),t("li",[t("strong",[v._v("多线程")]),v._v("：代码运行的环境不同，各线程独立，互不影响，避免阻塞。")])]),v._v(" "),t("p",[v._v("为了保证 JavaScript 的主要运行环境（浏览器），JavaScript 被设计成了单线程语言。")]),v._v(" "),t("p",[v._v("为了充分利用多核处理器的计算能力，HTML5 提出了 Web Worker 标准，允许 JavaScript 脚本创建多个子线程，但是子线程完全受控于主线程，且不得操作 DOM。因此，新标准并没有改变 JavaScript 单线程的本质。")]),v._v(" "),t("h1",{attrs:{id:"执行栈、任务队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行栈、任务队列"}},[v._v("#")]),v._v(" 执行栈、任务队列")]),v._v(" "),t("p",[v._v("在上图中，主线程运行的时候，产生 "),t("strong",[v._v("堆（heap）")]),v._v(" 和 "),t("strong",[v._v("栈（stack）")]),v._v("，栈中的代码调用各种 API，他们在 "),t("em",[v._v("任务队列")]),v._v(" 中加入各种事件（DOM Event，ajax，setTimeout...），只要栈中的代码执行完毕，主线程就会去读取任务队列，依次执行那些时间对应的回调函数。")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("堆（heap）")]),v._v("：对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("执行栈（stack）")]),v._v("：运行同步代码。执行栈中的代码（同步任务），总是在读取 "),t("em",[v._v("任务队列")]),v._v("（异步任务）之前执行。")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("任务队列（callback queue）")]),v._v("：")]),v._v(" "),t("p",[t("em",[v._v("任务队列")]),v._v(" 是一个事件的队列（也可以理解成消息的队列），IO 设备完成一项任务，就在 "),t("em",[v._v("任务队列")]),v._v(" 中添加一个事件，表示相关的异步任务可以进入 "),t("em",[v._v("执行栈")]),v._v(" 了。主线程读取 "),t("em",[v._v("任务队列")]),v._v("，就是读取里面有哪些事件。")]),v._v(" "),t("p",[t("em",[v._v("任务队列")]),v._v(" 中的事件，除了 IO 设备的事件外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等）。只要指定过回调函数，这些事件发生时就会进入 "),t("em",[v._v("任务队列")]),v._v("，等待主线程读取。")]),v._v(" "),t("p",[v._v("所谓 "),t("em",[v._v("回调函数（callback）")]),v._v("，就是那些会被主线程挂起来的代码。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。")]),v._v(" "),t("p",[t("em",[v._v("任务队列")]),v._v(" 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本是自动的，只要执行栈一清空。"),t("em",[v._v("任务队列")]),v._v(" 上第一位的事件就自动进入主线程。但是由于存在后文提到的 "),t("em",[v._v("定时器")]),v._v(" 功能，主线程首先要检查一下执行时间，某些事件只有到了规定的时间才能返回主线程。")])])]),v._v(" "),t("h2",{attrs:{id:"同步任务、异步任务、宏任务、微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步任务、异步任务、宏任务、微任务"}},[v._v("#")]),v._v(" 同步任务、异步任务、宏任务、微任务")]),v._v(" "),t("p",[v._v("单线程即意味着所有人物都需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就必须一直等着。")]),v._v(" "),t("h3",{attrs:{id:"同步任务、异步任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#同步任务、异步任务"}},[v._v("#")]),v._v(" 同步任务、异步任务")]),v._v(" "),t("p",[v._v("为此，JavaScript 设计者在广义上将所有任务分成两种："),t("strong",[v._v("同步任务（synchronous）")]),v._v("、"),t("strong",[v._v("异步任务（asynchronous）")]),v._v("，运行机制如下：")]),v._v(" "),t("ol",[t("li",[v._v("所有同步任务都在主线程上执行，形成一个 "),t("em",[v._v("执行栈")]),v._v("；")]),v._v(" "),t("li",[v._v("主线程外，还存在一个 "),t("em",[v._v("任务队列")]),v._v("，只要异步任务有了运行结果，就在任务队列中放置一个事件；")]),v._v(" "),t("li",[v._v("一旦执行栈中所有同步任务执行完毕，系统就会取出任务队列中事件对应的回调函数进入执行栈，开始执行；")]),v._v(" "),t("li",[v._v("主线程不断重复上面的第三部。")])]),v._v(" "),t("h3",{attrs:{id:"宏任务、微任务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务"}},[v._v("#")]),v._v(" 宏任务、微任务")]),v._v(" "),t("p",[v._v("除了广义上的定义，我们将任务进行更精细的定义，分为：")]),v._v(" "),t("ul",[t("li",[t("p",[t("strong",[v._v("宏任务（macro-task）")])]),v._v(" "),t("p",[v._v("包括整体代码 script，setTimeout，setInterval，ajax，dom操作")])]),v._v(" "),t("li",[t("p",[t("strong",[v._v("微任务（micro-task）")])]),v._v(" "),t("p",[v._v("Promise")])])]),v._v(" "),t("p",[v._v("运行机制如下：")]),v._v(" "),t("ol",[t("li",[v._v("首先将执行栈最开始的所有同步代码（宏任务）执行完成；")]),v._v(" "),t("li",[v._v("检查是否有微任务，如有则执行所有微任务；")]),v._v(" "),t("li",[v._v("取出任务队列中事件对应的回调函数（宏任务）进入执行栈并执行完成；")]),v._v(" "),t("li",[v._v("再检查是否有微任务，如有则执行所有的微任务；")]),v._v(" "),t("li",[v._v("主线程不断重复上面的 3、4 步。")])]),v._v(" "),t("p",[v._v("以上两种运行机制，主线程都从任务队列中读取事件，这个过程是循环不断的，所以整个这种运行机制又称为 "),t("strong",[v._v("Event Loop（事件循环）")])]),v._v(" "),t("h2",{attrs:{id:"settimeout、setinterval"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#settimeout、setinterval"}},[v._v("#")]),v._v(" setTimeout、setInterval")]),v._v(" "),t("p",[v._v("这两个函数内部运行机制完全一致，区别在于前者一次性执行，后者反复执行。")]),v._v(" "),t("p",[v._v("两者产生的任务都是 "),t("strong",[v._v("异步任务")]),v._v("，也属于 "),t("strong",[v._v("宏任务")]),v._v("。")]),v._v(" "),t("p",[v._v("setTimeout 接收两个参数，第一个是回调函数，第二个是延迟执行的毫秒数。")]),v._v(" "),t("p",[v._v("如果第二个参数设置为0或者不设置，意思 "),t("strong",[v._v("并不是立即执行，而是指定某个任务在主线程最早可得到的空闲时间执行，也就是说，尽可能早得执行。他在 "),t("em",[v._v("任务队列")]),v._v(" 的尾部添加一个事件，因此要等到同步任务和 "),t("em",[v._v("任务队列")]),v._v(" 现有的事件都处理完，才会得到执行。")])]),v._v(" "),t("p",[v._v("所以说，setTimeout 和 setInterval 第二个参数设置的时间并不是绝对的，它需要根据当前代码最终执行的时间来确定的，简单来说，如果当前代码执行的时间超出了推迟执行的时间，那么 setTimeout(fn, 100) 就和 setTimeout(fn, 0) 没有区别了。")]),v._v(" "),t("h2",{attrs:{id:"promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#promise"}},[v._v("#")]),v._v(" Promise")]),v._v(" "),t("p",[v._v("Promise 相对来说比较特殊，在 new Promise() 中传入的回调函数是会 "),t("strong",[v._v("立即执行")]),v._v(" 的，但是它的 "),t("strong",[v._v("then()")]),v._v(" 方法是在 "),t("strong",[v._v("执行栈之后，任务队列之前")]),v._v(" 执行的，它属于 "),t("strong",[v._v("微任务")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"process-nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#process-nexttick"}},[v._v("#")]),v._v(" process.nextTick")]),v._v(" "),t("p",[v._v("process.nextTick 是 Node.JS 提供的一个与 "),t("em",[v._v("任务队列")]),v._v(" 有关的方法，它产生的任务是放在 "),t("strong",[v._v("执行栈的尾部")]),v._v("，并不属于 "),t("strong",[v._v("宏任务")]),v._v(" 和 "),t("strong",[v._v("微任务")]),v._v("，因此它的任务 "),t("strong",[v._v("总是发生在所有异步任务之前")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"setimmediate"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#setimmediate"}},[v._v("#")]),v._v(" setImmediate")]),v._v(" "),t("p",[v._v("setImmediate 是 Node.js 提供的与 "),t("em",[v._v("任务队列")]),v._v(" 有关的方法，它产生的任务追加到 "),t("em",[v._v("任务队列")]),v._v(" 的尾部，它和 "),t("strong",[v._v("setTimeout(fn, 0)")]),v._v(" 很像，但是优先级低于 setTimeout。")]),v._v(" "),t("p",[v._v("有时候，setTimeout 会在 setImmediate 之前执行，有时会在之后执行，这是因为虽然 setTimeout 第二个参数设置为 0 或者不设置，但是 setTimeout 源码中，会指定一个具体的毫秒数（nodejs 为 1ms，浏览器为 4ms），而由于当前代码执行时间收到执行环境的影响，执行时间有所起伏。")]),v._v(" "),t("h2",{attrs:{id:"优先级"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优先级"}},[v._v("#")]),v._v(" 优先级")]),v._v(" "),t("ol",[t("li",[v._v("同步任务（宏任务）")]),v._v(" "),t("li",[v._v("process.nextTick")]),v._v(" "),t("li",[v._v("Promise（微任务）")]),v._v(" "),t("li",[v._v("setTimeout(fn)、setInterval(fn) （宏任务）")]),v._v(" "),t("li",[v._v("setimmediate（宏任务）")]),v._v(" "),t("li",[v._v("setTimeout(fn, time)、setInterval(fn, time)  time >0")])])])}),[],!1,null,null,null);_.default=s.exports}}]);