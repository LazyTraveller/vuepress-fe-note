(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{231:function(a,t,e){"use strict";e.r(t);var l=e(3),n=Object(l.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h3",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this"}},[a._v("#")]),a._v(" this")]),a._v(" "),e("p",[a._v("在函数执行时，"),e("code",[a._v("this")]),a._v("总是指向调用该函数的对象。要判断 "),e("code",[a._v("this")]),a._v("的指向，其实就是判断 "),e("code",[a._v("this")]),a._v("所在的函数属于谁。")]),a._v(" "),e("p",[a._v("在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：")]),a._v(" "),e("ul",[e("li",[a._v("有对象就指向调用对象")]),a._v(" "),e("li",[a._v("没调用对象就指向全局对象")]),a._v(" "),e("li",[a._v("用new构造就指向新对象")]),a._v(" "),e("li",[a._v("通过 apply 或 call 或 bind 来改变 this 的所指。")])]),a._v(" "),e("h4",{attrs:{id:"_1-函数有所属对象时-指向所属对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-函数有所属对象时-指向所属对象"}},[a._v("#")]),a._v(" 1）函数有所属对象时：指向所属对象")]),a._v(" "),e("p",[a._v("函数有所属对象时，通常通过 . 表达式调用，这时 this 自然指向所属对象。比如下面的例子：")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var myObject = {value: 100};\nmyObject.getValue = function () {\n  console.log(this.value);  // 输出 100\n\n  // 输出 { value: 100, getValue: [Function] }，\n  // 其实就是 myObject 对象本身\n  console.log(this);\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // => 100\ngetValue() 属于对象 myObject，并由 myOjbect 进行 . 调用，因此 this 指向对象 myObject。\n")])])]),e("h4",{attrs:{id:"_2-函数没有所属对象-指向全局对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数没有所属对象-指向全局对象"}},[a._v("#")]),a._v(" 2）函数没有所属对象：指向全局对象")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var myObject = {value: 100};\nmyObject.getValue = function () {\n  var foo = function () {\n    console.log(this.value) // => undefined\n    console.log(this);// 输出全局对象 global\n  };\n\n  foo();\n\n  return this.value;\n};\n\nconsole.log(myObject.getValue()); // => 100\n")])])]),e("p",[a._v("在上述代码块中，foo 函数虽然定义在 getValue 的函数体内，但实际上它既不属于 getValue 也不属于 myObject。foo 并没有被绑定在任何对象上，所以当调用时，它的 this 指针指向了全局对象 global。")]),a._v(" "),e("p",[a._v("据说这是个设计错误。")]),a._v(" "),e("h4",{attrs:{id:"_3-构造器中的-this-指向新对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-构造器中的-this-指向新对象"}},[a._v("#")]),a._v(" 3）构造器中的 this：指向新对象")]),a._v(" "),e("p",[a._v("js 中，我们通过 new 关键词来调用构造函数，此时 this 会绑定在该新对象上。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var SomeClass = function(){\n  this.value = 100;\n}\n\nvar myCreate = new SomeClass();\n\nconsole.log(myCreate.value); // 输出100\n")])])]),e("p",[a._v("顺便说一句，在 js 中，构造函数、普通函数、对象方法、闭包，这四者没有明确界线。界线都在人的心中。")]),a._v(" "),e("h4",{attrs:{id:"_4-apply-和-call-调用以及-bind-绑定-指向绑定的对象"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-apply-和-call-调用以及-bind-绑定-指向绑定的对象"}},[a._v("#")]),a._v(" 4） apply 和 call 调用以及 bind 绑定：指向绑定的对象")]),a._v(" "),e("p",[a._v("apply() 方法接受两个参数第一个是函数运行的作用域，另外一个是一个参数数组(arguments)。")]),a._v(" "),e("p",[a._v("call() 方法第一个参数的意义与 apply() 方法相同，只是其他的参数需要一个个列举出来。")]),a._v(" "),e("p",[a._v("简单来说，call 的方式更接近我们平时调用函数，而 apply 需要我们传递 Array 形式的数组给它。它们是可以互相转换的。")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("var myObject = {value: 100};\n\nvar foo = function(){\n  console.log(this);\n};\n\nfoo(); // 全局变量 global\nfoo.apply(myObject); // { value: 100 }\nfoo.call(myObject); // { value: 100 }\n\nvar newFoo = foo.bind(myObject);\nnewFoo(); // { value: 100 }```")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);