(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{317:function(e,v,_){"use strict";_.r(v);var r=_(3),t=Object(r.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h2",{attrs:{id:"proxy-相比较于-defineproperty-的优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#proxy-相比较于-defineproperty-的优势"}},[e._v("#")]),e._v(" Proxy 相比较于 defineProperty 的优势")]),e._v(" "),_("p",[_("code",[e._v("Object.defineProperty")]),e._v("是监听对象的字段而非对象本身，因此对于动态插入对象的字段，它无能为了，只能手动为其设置设置监听属性。")]),e._v(" "),_("p",[e._v("同时，"),_("code",[e._v("Object.defineProperty")]),e._v(" 无法监听对象中数组的变化，因此其他基于 "),_("code",[e._v("Object.defineProperty")]),e._v("都对数组做了一定的 Hack 处理。")]),e._v(" "),_("p",[e._v("Proxy 叫做代理器，它可以为一个对象设置代理，即监听对象本身，任何访问当前被监听的对象的操作，无论是对象本身亦或是对象的字段，都会被 Proxy 拦截，因此可以使用它来做一些双向绑定的操作。")]),e._v(" "),_("p",[e._v("鉴于兼容性的问题，目前仍然主要是使用"),_("code",[e._v("Object.defineProperty")]),e._v("更多，但是随着 Vue/3 的发布，Proxy 应该会逐渐淘汰"),_("code",[e._v("Object.defineProperty。")])]),e._v(" "),_("p",[e._v("创建一个对象的代理")]),e._v(" "),_("ul",[_("li",[e._v("handle 处理器对象")]),e._v(" "),_("li",[e._v("traps 捕获器对象")]),e._v(" "),_("li",[e._v("target 被代理的对象")])]),e._v(" "),_("p",[e._v("new Proxy(taregt, handler)")]),e._v(" "),_("p",[e._v("defineProperty")]),e._v(" "),_("ul",[_("li",[e._v("深度遍历，性能不好")]),e._v(" "),_("li",[e._v("兼容性好")]),e._v(" "),_("li",[e._v("只能劫持对象的属性，新属性不行。")]),e._v(" "),_("li",[e._v("不能监听数组")]),e._v(" "),_("li",[e._v("新的对象不支持。")])]),e._v(" "),_("p",[e._v("proxy 优势")]),e._v(" "),_("ul",[_("li",[e._v("监听整个对象而非属性")]),e._v(" "),_("li",[e._v("可以监听对象")]),e._v(" "),_("li",[e._v("更丰富的拦截方法")]),e._v(" "),_("li",[e._v("毕竟新标准，浏览器会注重性能优化的。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);